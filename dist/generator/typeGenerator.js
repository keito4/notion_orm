"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypeDefinitions = generateTypeDefinitions;
const fs_1 = require("fs");
const logger_1 = require("../utils/logger");
const client_1 = require("../notion/client");
async function generateTypeDefinitions(schema) {
    try {
        (0, fs_1.mkdirSync)('./generated', { recursive: true });
        // Notionクライアントを初期化
        const notionClient = new client_1.NotionClient();
        // 各モデルのデータベースからプロパティ情報を取得
        const modelSchemas = await Promise.all(schema.models.map(async (model) => {
            const database = await notionClient.getDatabaseSchema(model.notionDatabaseId);
            return { model, database };
        }));
        // 型定義を生成
        const typeDefinitions = generateModelTypes(modelSchemas);
        const indexFile = generateIndexFile(schema.models);
        (0, fs_1.writeFileSync)('./generated/types.ts', typeDefinitions);
        (0, fs_1.writeFileSync)('./generated/index.ts', indexFile);
        logger_1.logger.info('Generated type definitions in ./generated/types.ts');
    }
    catch (error) {
        logger_1.logger.error('Error generating type definitions:', error);
        throw error;
    }
}
function generateModelTypes(modelSchemas) {
    return `// Generated by notion-orm
import { NotionPropertyTypes } from './notionTypes';

${modelSchemas.map(({ model, database }) => `
${generateEnums(model, database)}

export interface ${model.name} {
  id: string;
  ${model.fields.map(field => {
        const property = findProperty(database.properties, field.name);
        const tsType = mapNotionTypeToTS(field.type, property);
        const optional = field.optional ? '?' : '';
        return `${field.name}${optional}: ${tsType};`;
    }).join('\n  ')}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${model.fields.map(field => {
        const property = findProperty(database.properties, field.name);
        const tsType = mapNotionTypeToTS(field.type, property);
        const optional = field.optional ? '?' : '';
        return `${field.name}${optional}: ${tsType};`;
    }).join('\n  ')}
}
`).join('\n')}

export interface NotionProperty {
  id: string;
  type: NotionPropertyTypes;
  name: string;
}
`;
}
function generateEnums(model, database) {
    const enums = [];
    // select/multi_selectプロパティの選択肢からEnumを生成
    model.fields.forEach(field => {
        const property = findProperty(database.properties, field.name);
        if (property && (property.type === 'select' || property.type === 'multi_select')) {
            const options = property[property.type].options;
            if (options && options.length > 0) {
                const enumName = `${model.name}${capitalizeFirstLetter(field.name)}`;
                const enumValues = options.map((opt) => `  ${makeEnumKey(opt.name)} = "${opt.name}"`).join(',\n');
                enums.push(`export enum ${enumName} {
${enumValues}
}`);
            }
        }
    });
    return enums.join('\n\n');
}
function findProperty(properties, fieldName) {
    return properties[fieldName] || Object.values(properties).find((prop) => prop.name === fieldName);
}
function mapNotionTypeToTS(notionType, property) {
    if (property) {
        if (property.type === 'select') {
            return `${property.name}Select`;
        }
        if (property.type === 'multi_select') {
            return `${property.name}Select[]`;
        }
    }
    const typeMap = {
        'title': 'string',
        'rich_text': 'string',
        'number': 'number',
        'select': 'string',
        'multi_select': 'string[]',
        'date': 'string',
        'checkbox': 'boolean',
        'url': 'string',
        'email': 'string',
        'phone_number': 'string',
        'files': 'Array<{ name: string; url: string }>',
        'people': 'Array<{ id: string; name: string; avatar_url?: string }>'
    };
    return typeMap[notionType] || 'any';
}
function generateIndexFile(models) {
    return `// Generated by notion-orm
export * from './types';
export * from './client';
`;
}
function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
function makeEnumKey(value) {
    return value
        .replace(/[^a-zA-Z0-9]/g, '_')
        .replace(/^(\d)/, '_$1')
        .toUpperCase();
}
