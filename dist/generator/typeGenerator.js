"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypeDefinitions = generateTypeDefinitions;
const fs_1 = require("fs");
const logger_1 = require("../utils/logger");
const client_1 = require("../notion/client");
const notionTypes_1 = require("../types/notionTypes");
const path_1 = require("path");
async function generateTypeDefinitions(schema) {
    try {
        const outputDir = schema.output?.directory || './generated';
        const typeFile = schema.output?.typeDefinitionFile || 'types.ts';
        const outputPath = (0, path_1.resolve)(outputDir, typeFile);
        // 出力ディレクトリの作成
        (0, fs_1.mkdirSync)((0, path_1.dirname)(outputPath), { recursive: true });
        const notionClient = new client_1.NotionClient();
        const modelSchemas = await Promise.all(schema.models.map(async (model) => {
            try {
                const database = await notionClient.getDatabaseSchema(model.notionDatabaseId);
                logger_1.logger.info(`Retrieved database schema for model ${model.name}`);
                return { model, database };
            }
            catch (error) {
                logger_1.logger.error(`Failed to retrieve database schema for model ${model.name}:`, error);
                throw error;
            }
        }));
        const typeDefinitions = generateModelTypes(modelSchemas);
        const indexFile = generateIndexFile(schema);
        (0, fs_1.writeFileSync)(outputPath, typeDefinitions);
        (0, fs_1.writeFileSync)((0, path_1.resolve)((0, path_1.dirname)(outputPath), 'index.ts'), indexFile);
        logger_1.logger.info(`Generated type definitions in ${outputPath}`);
    }
    catch (error) {
        logger_1.logger.error('Error generating type definitions:', error);
        throw error;
    }
}
function generateModelTypes(modelSchemas) {
    // 既存のコードと同じ
    return `// Generated by notion-orm
import { NotionPropertyTypes } from '../types/notionTypes';

${modelSchemas.map(({ model, database }) => `
export interface ${model.name} {
  id: string;
  ${Object.entries(database.properties)
        .map(([key, prop]) => {
        const typeStr = getPropertyType(prop.type);
        const isOptional = prop.type !== notionTypes_1.NotionPropertyTypes.Title;
        return `${sanitizePropertyName(key)}${isOptional ? '?' : ''}: ${typeStr};`;
    })
        .join('\n  ')}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${Object.entries(database.properties)
        .map(([key, prop]) => {
        const typeStr = getPropertyType(prop.type);
        const isOptional = prop.type !== notionTypes_1.NotionPropertyTypes.Title;
        return `${sanitizePropertyName(key)}${isOptional ? '?' : ''}: ${typeStr};`;
    })
        .join('\n  ')}
}
`).join('\n')}`;
}
function generateIndexFile(schema) {
    const typeFile = schema.output?.typeDefinitionFile || 'types';
    const clientFile = schema.output?.clientFile || 'client';
    return `// Generated by notion-orm
export * from './${typeFile.replace(/\.ts$/, '')}';
export * from './${clientFile.replace(/\.ts$/, '')}';
`;
}
// 既存のヘルパー関数は変更なし
function sanitizePropertyName(name) {
    if (name.match(/[^a-zA-Z0-9_$]/)) {
        return `'${name}'`;
    }
    return name;
}
function getPropertyType(type) {
    switch (type) {
        case notionTypes_1.NotionPropertyTypes.Title:
        case notionTypes_1.NotionPropertyTypes.RichText:
            return 'string';
        case notionTypes_1.NotionPropertyTypes.Number:
            return 'number';
        case notionTypes_1.NotionPropertyTypes.Select:
            return 'string';
        case notionTypes_1.NotionPropertyTypes.MultiSelect:
            return 'string[]';
        case notionTypes_1.NotionPropertyTypes.Date:
            return 'string | null';
        case notionTypes_1.NotionPropertyTypes.Checkbox:
            return 'boolean';
        case notionTypes_1.NotionPropertyTypes.People:
            return 'Array<{ id: string; name: string; avatar_url?: string }>';
        case notionTypes_1.NotionPropertyTypes.Relation:
            return 'Array<{ id: string }>';
        case notionTypes_1.NotionPropertyTypes.Formula:
            return 'string';
        default:
            logger_1.logger.warn(`Unsupported Notion property type: ${type}`);
            return 'string';
    }
}
