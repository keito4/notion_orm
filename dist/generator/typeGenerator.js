"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypeDefinitions = generateTypeDefinitions;
const fs_1 = require("fs");
const logger_1 = require("../utils/logger");
const client_1 = require("../notion/client");
const notionTypes_1 = require("../types/notionTypes");
async function generateTypeDefinitions(schema) {
    try {
        (0, fs_1.mkdirSync)('./generated', { recursive: true });
        const notionClient = new client_1.NotionClient();
        const modelSchemas = await Promise.all(schema.models.map(async (model) => {
            try {
                const database = await notionClient.getDatabaseSchema(model.notionDatabaseId);
                logger_1.logger.info(`Retrieved database schema for model ${model.name}`);
                return { model, database };
            }
            catch (error) {
                logger_1.logger.error(`Failed to retrieve database schema for model ${model.name}:`, error);
                throw error;
            }
        }));
        const typeDefinitions = generateModelTypes(modelSchemas);
        const indexFile = generateIndexFile();
        (0, fs_1.writeFileSync)('./generated/types.ts', typeDefinitions);
        (0, fs_1.writeFileSync)('./generated/index.ts', indexFile);
        logger_1.logger.info('Generated type definitions in ./generated/types.ts');
    }
    catch (error) {
        logger_1.logger.error('Error generating type definitions:', error);
        throw error;
    }
}
function generateModelTypes(modelSchemas) {
    return `// Generated by notion-orm
import { NotionPropertyTypes } from '../types/notionTypes';

${modelSchemas.map(({ model, database }) => `
export interface ${model.name} {
  id: string;
  ${Object.entries(database.properties)
        .map(([key, prop]) => {
        const typeStr = getPropertyType(prop.type);
        const isOptional = prop.type !== notionTypes_1.NotionPropertyTypes.Title;
        return `${key}${isOptional ? '?' : ''}: ${typeStr};`;
    })
        .join('\n  ')}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${Object.entries(database.properties)
        .map(([key, prop]) => {
        const typeStr = getPropertyType(prop.type);
        const isOptional = prop.type !== notionTypes_1.NotionPropertyTypes.Title;
        return `${key}${isOptional ? '?' : ''}: ${typeStr};`;
    })
        .join('\n  ')}
}
`).join('\n')}`;
}
function getPropertyType(type) {
    switch (type) {
        case notionTypes_1.NotionPropertyTypes.Title:
        case notionTypes_1.NotionPropertyTypes.RichText:
            return 'string';
        case notionTypes_1.NotionPropertyTypes.Number:
            return 'number';
        case notionTypes_1.NotionPropertyTypes.Select:
            return 'string';
        case notionTypes_1.NotionPropertyTypes.MultiSelect:
            return 'string[]';
        case notionTypes_1.NotionPropertyTypes.Date:
            return 'string | null';
        case notionTypes_1.NotionPropertyTypes.Checkbox:
            return 'boolean';
        case notionTypes_1.NotionPropertyTypes.People:
            return 'Array<{ id: string; name: string; avatar_url?: string }>';
        case notionTypes_1.NotionPropertyTypes.Relation:
            return 'Array<{ id: string }>';
        case notionTypes_1.NotionPropertyTypes.Formula:
            return 'any';
        default:
            logger_1.logger.warn(`Unsupported Notion property type: ${type}`);
            return 'string';
    }
}
function generateIndexFile() {
    return `// Generated by notion-orm
export * from './types';
export * from './client';
`;
}
