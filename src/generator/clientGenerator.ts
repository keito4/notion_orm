import { writeFileSync, mkdirSync } from "fs";
import { resolve, dirname } from "path";
import { Schema } from "../types";
import { logger } from "../utils/logger";
import { NotionPropertyTypes } from "../types/notionTypes";

export async function generateClient(schema: Schema): Promise<void> {
  try {
    if (!schema.models || !Array.isArray(schema.models)) {
      throw new Error("Invalid schema: models array is required");
    }

    for (const model of schema.models) {
      if (!model.fields || !Array.isArray(model.fields)) {
        throw new Error("Invalid schema: model fields are required");
      }
    }

    const outputDir = schema.output?.directory || "./generated";
    const clientFile = schema.output?.clientFile || "client.ts";
    const typeFile = schema.output?.typeDefinitionFile || "types.ts";

    // 出力ディレクトリの作成
    mkdirSync(outputDir, { recursive: true });

    // 型定義ファイルを生成
    const typeDefinitions = generateTypeDefinitions(schema);
    const typesPath = resolve(outputDir, typeFile);
    writeFileSync(typesPath, typeDefinitions);

    // クライアントコードを生成
    const clientCode = generateClientCode(schema);
    const clientPath = resolve(outputDir, clientFile);
    writeFileSync(clientPath, clientCode);

    logger.info(`Generated client code in ${clientPath}`);
  } catch (error) {
    logger.error("Error generating client:", error);
    throw error;
  }
}

function generateTypeDefinitions(schema: Schema): string {
  return `// Generated by notion-orm
import { NotionPropertyTypes } from "../types/notionTypes";

${schema.models
    .map(
      (model) => `
export interface ${model.name} {
  id: string;
  ${model.fields
        .map((field) => {
          const typeStr = getPropertyType(field.type);
          return `${field.name}${field.optional ? "?" : ""}: ${typeStr};`;
        })
        .join("\n  ")}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${model.fields
        .map((field) => {
          const typeStr = getPropertyType(field.type);
          return `${field.name}${field.optional ? "?" : ""}: ${typeStr};`;
        })
        .join("\n  ")}
}
`
    )
    .join("\n")}`;
}

function generateClientCode(schema: Schema): string {
  const typeFile = schema.output?.typeDefinitionFile || "types";

  return `// Generated by notion-orm
import { Client } from "@notionhq/client";
import { QueryBuilder } from "../query/builder";
import { ${schema.models.map((m) => m.name).join(", ")} } from "./${typeFile.replace(/\.ts$/, "")}";

export class NotionOrmClient {
  private notion: Client;

  constructor(apiKey: string) {
    this.notion = new Client({ auth: apiKey });
  }

  ${schema.models
      .map(
        (model) => `
  query${model.name}(): QueryBuilder<${model.name}> {
    return new QueryBuilder<${model.name}>(
      this.notion,
      "${model.notionDatabaseId}",
      "${model.name}"
    );
  }`
      )
      .join("\n\n")}
}
`;
}

function getPropertyType(type: string): string {
  switch (type.toLowerCase()) {
    case "title":
    case "rich_text":
    case "text":
    case "select":
      return "string";
    case "number":
      return "number";
    case "multi_select":
      return "string[]";
    case "date":
    case "datetime":
      return "string | null";
    case "checkbox":
    case "boolean":
      return "boolean";
    case "people":
      return "Array<{ id: string; name: string; avatar_url?: string }>";
    case "relation":
      return "Array<{ id: string }>";
    case "formula":
    case "rollup":
      return "string";
    case "files":
      return "Array<{ name: string; url: string }>";
    default:
      logger.warn(`Unsupported Notion property type: ${type}`);
      return "string";
  }
}