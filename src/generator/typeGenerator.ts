import { writeFileSync, mkdirSync } from 'fs';
import { Schema, Model } from '../types';
import { logger } from '../utils/logger';
import { NotionClient } from '../notion/client';

export async function generateTypeDefinitions(schema: Schema): Promise<void> {
  try {
    mkdirSync('./generated', { recursive: true });

    // Notionクライアントを初期化
    const notionClient = new NotionClient();

    // 各モデルのデータベースからプロパティ情報を取得
    const modelSchemas = await Promise.all(
      schema.models.map(async model => {
        const database = await notionClient.getDatabaseSchema(model.notionDatabaseId);
        return { model, database };
      })
    );

    // 型定義を生成
    const typeDefinitions = generateModelTypes(modelSchemas);
    const indexFile = generateIndexFile(schema.models);

    writeFileSync('./generated/types.ts', typeDefinitions);
    writeFileSync('./generated/index.ts', indexFile);

    logger.info('Generated type definitions in ./generated/types.ts');
  } catch (error) {
    logger.error('Error generating type definitions:', error);
    throw error;
  }
}

function generateModelTypes(modelSchemas: Array<{ model: Model; database: any }>): string {
  return `// Generated by notion-orm
import { NotionPropertyTypes } from './notionTypes';

${modelSchemas.map(({ model, database }) => `
${generateEnums(model, database)}

export interface ${model.name} {
  id: string;
  ${model.fields.map(field => {
    const property = findProperty(database.properties, field.name);
    const tsType = mapNotionTypeToTS(field.type, property);
    const optional = field.optional ? '?' : '';
    return `${field.name}${optional}: ${tsType};`;
  }).join('\n  ')}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${model.fields.map(field => {
    const property = findProperty(database.properties, field.name);
    const tsType = mapNotionTypeToTS(field.type, property);
    const optional = field.optional ? '?' : '';
    return `${field.name}${optional}: ${tsType};`;
  }).join('\n  ')}
}
`).join('\n')}

export interface NotionProperty {
  id: string;
  type: NotionPropertyTypes;
  name: string;
}
`;
}

function generateEnums(model: Model, database: any): string {
  const enums: string[] = [];

  // select/multi_selectプロパティの選択肢からEnumを生成
  model.fields.forEach(field => {
    const property = findProperty(database.properties, field.name);
    if (property && (property.type === 'select' || property.type === 'multi_select')) {
      const options = property[property.type].options;
      if (options && options.length > 0) {
        const enumName = `${model.name}${capitalizeFirstLetter(field.name)}`;
        const enumValues = options.map((opt: any) => 
          `  ${makeEnumKey(opt.name)} = "${opt.name}"`
        ).join(',\n');

        enums.push(`export enum ${enumName} {
${enumValues}
}`);
      }
    }
  });

  return enums.join('\n\n');
}

function findProperty(properties: any, fieldName: string): any {
  return properties[fieldName] || Object.values(properties).find((prop: any) => prop.name === fieldName);
}

function mapNotionTypeToTS(notionType: string, property?: any): string {
  if (property) {
    if (property.type === 'select') {
      return `${property.name}Select`;
    }
    if (property.type === 'multi_select') {
      return `${property.name}Select[]`;
    }
  }

  const typeMap: Record<string, string> = {
    'title': 'string',
    'rich_text': 'string',
    'number': 'number',
    'select': 'string',
    'multi_select': 'string[]',
    'date': 'string',
    'checkbox': 'boolean',
    'url': 'string',
    'email': 'string',
    'phone_number': 'string',
    'files': 'Array<{ name: string; url: string }>',
    'people': 'Array<{ id: string; name: string; avatar_url?: string }>'
  };

  return typeMap[notionType] || 'any';
}

function generateIndexFile(models: Model[]): string {
  return `// Generated by notion-orm
export * from './types';
export * from './client';
`;
}

function capitalizeFirstLetter(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function makeEnumKey(value: string): string {
  return value
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/^(\d)/, '_$1')
    .toUpperCase();
}