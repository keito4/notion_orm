import { writeFileSync, mkdirSync } from 'fs';
import { Schema } from '../types';
import { logger } from '../utils/logger';
import { NotionClient } from '../notion/client';
import { NotionPropertyTypes } from '../types/notionTypes';

interface GeneratedModel {
  model: {
    name: string;
    notionDatabaseId: string;
  };
  database: {
    properties: Record<string, {
      type: NotionPropertyTypes;
      name: string;
    }>;
  };
}

export async function generateTypeDefinitions(schema: Schema): Promise<void> {
  try {
    mkdirSync('./generated', { recursive: true });
    const notionClient = new NotionClient();

    const modelSchemas: GeneratedModel[] = await Promise.all(
      schema.models.map(async model => {
        try {
          const database = await notionClient.getDatabaseSchema(model.notionDatabaseId);
          logger.info(`Retrieved database schema for model ${model.name}`);
          return { model, database };
        } catch (error) {
          logger.error(`Failed to retrieve database schema for model ${model.name}:`, error);
          throw error;
        }
      })
    );

    const typeDefinitions = generateModelTypes(modelSchemas);
    const indexFile = generateIndexFile();

    writeFileSync('./generated/types.ts', typeDefinitions);
    writeFileSync('./generated/index.ts', indexFile);

    logger.info('Generated type definitions in ./generated/types.ts');
  } catch (error) {
    logger.error('Error generating type definitions:', error);
    throw error;
  }
}

function generateModelTypes(modelSchemas: GeneratedModel[]): string {
  return `// Generated by notion-orm
import { NotionPropertyTypes } from '../types/notionTypes';

${modelSchemas.map(({ model, database }) => `
export interface ${model.name} {
  id: string;
  ${Object.entries(database.properties)
    .map(([key, prop]) => {
      const typeStr = getPropertyType(prop.type);
      const isOptional = prop.type !== NotionPropertyTypes.Title;
      return `${key}${isOptional ? '?' : ''}: ${typeStr};`;
    })
    .join('\n  ')}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${Object.entries(database.properties)
    .map(([key, prop]) => {
      const typeStr = getPropertyType(prop.type);
      const isOptional = prop.type !== NotionPropertyTypes.Title;
      return `${key}${isOptional ? '?' : ''}: ${typeStr};`;
    })
    .join('\n  ')}
}
`).join('\n')}`;
}

function getPropertyType(type: NotionPropertyTypes): string {
  switch (type) {
    case NotionPropertyTypes.Title:
    case NotionPropertyTypes.RichText:
      return 'string';
    case NotionPropertyTypes.Number:
      return 'number';
    case NotionPropertyTypes.Select:
      return 'string';
    case NotionPropertyTypes.MultiSelect:
      return 'string[]';
    case NotionPropertyTypes.Date:
      return 'string | null';
    case NotionPropertyTypes.Checkbox:
      return 'boolean';
    case NotionPropertyTypes.People:
      return 'Array<{ id: string; name: string; avatar_url?: string }>';
    case NotionPropertyTypes.Relation:
      return 'Array<{ id: string }>';
    case NotionPropertyTypes.Formula:
      return 'any';
    default:
      logger.warn(`Unsupported Notion property type: ${type}`);
      return 'string';
  }
}

function generateIndexFile(): string {
  return `// Generated by notion-orm
export * from './types';
export * from './client';
`;
}