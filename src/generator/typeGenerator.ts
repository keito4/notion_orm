import { writeFileSync, mkdirSync } from 'fs';
import { Schema } from '../types';
import { logger } from '../utils/logger';
import { NotionClient } from '../notion/client';
import { NotionPropertyTypes } from '../types/notionTypes';
import { resolve, dirname } from 'path';

interface GeneratedModel {
  model: {
    name: string;
    notionDatabaseId: string;
  };
  database: {
    properties: Record<string, {
      type: NotionPropertyTypes;
      name: string;
    }>;
  };
}

export async function generateTypeDefinitions(schema: Schema): Promise<void> {
  try {
    const outputDir = schema.output?.directory || './generated';
    const typeFile = schema.output?.typeDefinitionFile || 'types.ts';
    const outputPath = resolve(outputDir, typeFile);

    // 出力ディレクトリの作成
    mkdirSync(dirname(outputPath), { recursive: true });
    const notionClient = new NotionClient();

    const modelSchemas: GeneratedModel[] = await Promise.all(
      schema.models.map(async (model) => {
        try {
          const database = await notionClient.getDatabaseSchema(model.notionDatabaseId);
          logger.info(`Retrieved database schema for model ${model.name}`);
          return { model, database };
        } catch (error) {
          logger.error(`Failed to retrieve database schema for model ${model.name}:`, error);
          throw error;
        }
      })
    );

    const typeDefinitions = generateModelTypes(modelSchemas);
    const indexFile = generateIndexFile(schema);

    writeFileSync(outputPath, typeDefinitions);
    writeFileSync(resolve(dirname(outputPath), 'index.ts'), indexFile);

    logger.info(`Generated type definitions in ${outputPath}`);
  } catch (error) {
    logger.error('Error generating type definitions:', error);
    throw error;
  }
}

function generateModelTypes(modelSchemas: GeneratedModel[]): string {
  // 既存のコードと同じ
  return `// Generated by notion-orm
import { NotionPropertyTypes } from '../types/notionTypes';

${modelSchemas.map(({ model, database }) => `
export interface ${model.name} {
  id: string;
  ${Object.entries(database.properties)
    .map(([key, prop]) => {
      const typeStr = getPropertyType(prop.type);
      const isOptional = prop.type !== NotionPropertyTypes.Title;
      return `${sanitizePropertyName(key)}${isOptional ? '?' : ''}: ${typeStr};`;
    })
    .join('\n  ')}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${Object.entries(database.properties)
    .map(([key, prop]) => {
      const typeStr = getPropertyType(prop.type);
      const isOptional = prop.type !== NotionPropertyTypes.Title;
      return `${sanitizePropertyName(key)}${isOptional ? '?' : ''}: ${typeStr};`;
    })
    .join('\n  ')}
}
`).join('\n')}`;
}

function generateIndexFile(schema: Schema): string {
  const typeFile = schema.output?.typeDefinitionFile || 'types';
  const clientFile = schema.output?.clientFile || 'client';

  return `// Generated by notion-orm
export * from './${typeFile.replace(/\.ts$/, '')}';
export * from './${clientFile.replace(/\.ts$/, '')}';
`;
}

// 既存のヘルパー関数は変更なし
function sanitizePropertyName(name: string): string {
  if (name.match(/[^a-zA-Z0-9_$]/)) {
    return `'${name}'`;
  }
  return name;
}

function getPropertyType(type: NotionPropertyTypes): string {
  switch (type) {
    case NotionPropertyTypes.Title:
    case NotionPropertyTypes.RichText:
      return 'string';
    case NotionPropertyTypes.Number:
      return 'number';
    case NotionPropertyTypes.Select:
      return 'string';
    case NotionPropertyTypes.MultiSelect:
      return 'string[]';
    case NotionPropertyTypes.Date:
      return 'string | null';
    case NotionPropertyTypes.Checkbox:
      return 'boolean';
    case NotionPropertyTypes.People:
      return 'Array<{ id: string; name: string; avatar_url?: string }>';
    case NotionPropertyTypes.Relation:
      return 'Array<{ id: string }>';
    case NotionPropertyTypes.Formula:
      return 'string';
    default:
      logger.warn(`Unsupported Notion property type: ${type}`);
      return 'string';
  }
}