import { writeFileSync, mkdirSync } from 'fs';
import { Schema, Model } from '../types';
import { logger } from '../utils/logger';
import { NotionClient } from '../notion/client';
import { NotionPropertyTypes, NotionDatabaseProperty, NotionSelectProperty, NotionMultiSelectProperty } from '../types/notionTypes';

export async function generateTypeDefinitions(schema: Schema): Promise<void> {
  try {
    mkdirSync('./generated', { recursive: true });

    // Notionクライアントを初期化
    const notionClient = new NotionClient();

    // 各モデルのデータベースからプロパティ情報を取得
    const modelSchemas = await Promise.all(
      schema.models.map(async model => {
        const database = await notionClient.getDatabaseSchema(model.notionDatabaseId);
        return { model, database };
      })
    );

    // 型定義を生成
    const typeDefinitions = generateModelTypes(modelSchemas);
    const indexFile = generateIndexFile(schema.models);

    writeFileSync('./generated/types.ts', typeDefinitions);
    writeFileSync('./generated/index.ts', indexFile);

    logger.info('Generated type definitions in ./generated/types.ts');
  } catch (error) {
    logger.error('Error generating type definitions:', error);
    throw error;
  }
}

function generateModelTypes(modelSchemas: Array<{ model: Model; database: { properties: Record<string, NotionDatabaseProperty> } }>): string {
  return `// Generated by notion-orm
import { NotionPropertyTypes } from '../types/notionTypes';

${modelSchemas.map(({ model, database }) => `
${generatePropertyEnums(model, database)}

export interface ${model.name} {
  id: string;
  ${Object.entries(database.properties).map(([key, property]) => {
    const tsType = mapNotionTypeToTS(property, model);
    const optional = property.type !== NotionPropertyTypes.Title ? '?' : '';
    return `${property.name}${optional}: ${tsType};`;
  }).join('\n  ')}
  createdTime: string;
  lastEditedTime: string;
}

export interface ${model.name}Input {
  ${Object.entries(database.properties).map(([key, property]) => {
    const tsType = mapNotionTypeToTS(property, model);
    const optional = property.type !== NotionPropertyTypes.Title ? '?' : '';
    return `${property.name}${optional}: ${tsType};`;
  }).join('\n  ')}
}
`).join('\n')}`;
}

function generatePropertyEnums(model: Model, database: { properties: Record<string, NotionDatabaseProperty> }): string {
  const enums: string[] = [];

  // select/multi_selectプロパティの選択肢からEnumを生成
  Object.entries(database.properties).forEach(([key, property]) => {
    if (isSelectProperty(property) || isMultiSelectProperty(property)) {
      const options = isSelectProperty(property)
        ? property.select.options
        : property.multi_select.options;

      if (options && options.length > 0) {
        const enumName = `${model.name}${capitalizeFirstLetter(property.name)}`;
        const enumValues = options.map(opt => 
          `  ${makeEnumKey(opt.name)} = "${opt.name}"`
        ).join(',\n');

        enums.push(`export enum ${enumName} {
${enumValues}
}`);
      }
    }
  });

  return enums.join('\n\n');
}

// Type guards for Notion property types
function isSelectProperty(property: NotionDatabaseProperty): property is NotionSelectProperty {
  return property.type === NotionPropertyTypes.Select;
}

function isMultiSelectProperty(property: NotionDatabaseProperty): property is NotionMultiSelectProperty {
  return property.type === NotionPropertyTypes.MultiSelect;
}

function mapNotionTypeToTS(property: NotionDatabaseProperty, model: Model): string {
  switch (property.type) {
    case NotionPropertyTypes.Title:
    case NotionPropertyTypes.RichText:
      return 'string';
    case NotionPropertyTypes.Number:
      return 'number';
    case NotionPropertyTypes.Select:
      if (isSelectProperty(property) && property.select?.options?.length) {
        return `${model.name}${capitalizeFirstLetter(property.name)}`;
      }
      return 'string';
    case NotionPropertyTypes.MultiSelect:
      if (isMultiSelectProperty(property) && property.multi_select?.options?.length) {
        return `${model.name}${capitalizeFirstLetter(property.name)}[]`;
      }
      return 'string[]';
    case NotionPropertyTypes.Date:
      return 'string';
    case NotionPropertyTypes.Checkbox:
      return 'boolean';
    case NotionPropertyTypes.People:
      return 'Array<{ id: string; name: string; avatar_url?: string }>';
    case NotionPropertyTypes.Relation:
      return 'Array<{ id: string }>';
    case NotionPropertyTypes.Formula:
      return 'any';
    default:
      logger.warn(`Unsupported Notion property type: ${String(property.type)}`);
      return 'any';
  }
}

function generateIndexFile(models: Model[]): string {
  return `// Generated by notion-orm
export * from './types';
export * from './client';
`;
}

function capitalizeFirstLetter(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function makeEnumKey(value: string): string {
  return value
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/^(\d)/, '_$1')
    .toUpperCase();
}