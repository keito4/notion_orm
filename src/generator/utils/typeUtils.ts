import { Model, Field, Schema } from "../../types";
import { logger } from "../../utils/logger";

export interface TypeGenerationOptions {
  includeImports?: boolean;
  includeInputTypes?: boolean;
  typeMode?: "client" | "notion";
}

export function generateInterfaceDefinition(
  model: Model,
  schema: Schema,
  options: TypeGenerationOptions = {}
): string {
  const { includeInputTypes = true, typeMode = "notion" } = options;

  let result = `
export interface ${model.name} {
  id: string;
  ${model.fields
    .map((field) => {
      const typeStr = getFieldType(field, schema, typeMode);
      const propertyName = typeMode === "notion" ? sanitizePropertyName(field.name) : field.name;
      return `${propertyName}${field.optional ? "?" : ""}: ${typeStr};`;
    })
    .join("\n  ")}
  createdTime: string;
  lastEditedTime: string;
}`;

  if (includeInputTypes) {
    result += `

export interface ${model.name}Input {
  ${model.fields
    .map((field) => {
      const typeStr = getFieldType(field, schema, typeMode);
      const propertyName = typeMode === "notion" ? sanitizePropertyName(field.name) : field.name;
      return `${propertyName}${field.optional ? "?" : ""}: ${typeStr};`;
    })
    .join("\n  ")}
}`;
  }

  return result;
}

export function generateModelTypes(
  models: Model[],
  schema: Schema,
  options: TypeGenerationOptions = {}
): string {
  const { includeImports = false, typeMode = "notion" } = options;

  let result = "";

  if (includeImports && typeMode === "client") {
    result += `
import { NotionPropertyTypes } from "notionmodelsync";`;
  } else if (includeImports && typeMode === "notion") {
    result += `// Generated by notion-orm

`;
  }

  result += models
    .map((model) => generateInterfaceDefinition(model, schema, options))
    .join("\n");

  return result.trim();
}

function getFieldType(field: Field, schema: Schema, typeMode: "client" | "notion"): string {
  if (typeMode === "client") {
    return getFieldTsType(field, schema);
  } else {
    return getNotionPropertyType(field.notionType);
  }
}

function getFieldTsType(field: Field, schema: Schema): string {
  const modelNames = schema.models.map((m) => m.name);
  let baseType = field.type;
  
  if (modelNames.includes(field.type)) {
    baseType = field.type;
  } else {
    switch (field.type) {
      case "String":
        baseType = "string";
        break;
      case "Boolean":
        baseType = "boolean";
        break;
      case "Number":
        baseType = "number";
        break;
      case "Json":
        // Use Record<string, unknown> instead of any for better type safety
        baseType = "Record<string, unknown>";
        break;
      case "DateTime":
        baseType = "string";
        break;
      default:
        // Log warning and fallback to string, not any
        logger.warn(`Unknown type: ${field.type}, falling back to string`);
        baseType = "string";
        break;
    }
  }
  
  if (field.isArray) {
    baseType += "[]";
  }
  
  return baseType;
}

function getNotionPropertyType(type: string): string {
  switch (type.toLowerCase()) {
    case "title":
    case "rich_text":
    case "text":
      return "string";
    case "number":
      return "number";
    case "select":
      return "string";
    case "multi_select":
      return "string[]";
    case "date":
    case "datetime":
      return "string | null";
    case "checkbox":
    case "boolean":
      return "boolean";
    case "people":
      return "Array<{ id: string; name: string; avatar_url?: string }>";
    case "relation":
      return "Array<{ id: string }>";
    case "formula":
    case "rollup":
      return "string";
    case "files":
      return "Array<{ name: string; url: string }>";
    default:
      logger.warn(`Unsupported Notion property type: ${type}`);
      return "string";
  }
}

function sanitizePropertyName(name: string): string {
  return name.match(/[^a-zA-Z0-9_$]/) ? `'${name}'` : name;
}